local ffi = require("ffi")
local engine = engine
local Package = SDKGen.Package
local GeneratedClasses = {}
local DefaultClass = engine.FindObject("Class Core.Default__Class", engine.Classes.UClass)
local CLASS_ALIGN = 4

-- Add the classes added manually to the generated list so they aren't generated again
for _, v in pairs(engine.Classes) do
	table.insert(GeneratedClasses, v.static)
end

local Class = {}
Class.__index = Class

function Class.new(obj)
	return setmetatable({ ClassObj = ffi.cast("struct UClass*", obj), UnknownDataIndex = 0 }, Class)
end

function Class:GeneratePrereqs(inPackage)
	local class = self.ClassObj
	local classPackage = class:GetPackageObject()
	local classText = ""

	if IsNull(classPackage) or classPackage ~= inPackage then
		return classText
	end

	if class == DefaultClass then return end -- Skip the default because it's a dummy
	if table.contains(GeneratedClasses, class) then return end -- Skip it if we've already made it

	-- First, check to see if this class has a base. If it does, make sure we have generated it before
	-- we move on.

	local base = class.UStruct.SuperField

	if 	NotNull(base)
		and base ~= class
		and not table.contains(GeneratedClasses, base) 
	then
		classText = classText .. Class.new(base):GeneratePrereqs(inPackage)
	end

	-- When we're generating structs, we had to check for field types which hadn't
	-- yet been generated, but since classes are loaded last of all the data structures
	-- everything should already be there. Only thing we need to do is generate the
	-- TArray definitions, if there are any.

	local classField = ffi.cast("struct UProperty*", class.UStruct.Children)
	while NotNull(classField) do -- Foreach property in the class

		if classField:IsA(engine.Classes.UArrayProperty) then
			classField = ffi.cast("struct UArrayProperty*", classField)

			local innerProperty = classField.UArrayProperty.Inner

			-- Check if we need to generate the TArray template for the inner type
			-- and do it if we need to.
			if not SDKGen.TArrayTypeGenerated(innerProperty) then
				classText = classText .. SDKGen.GenerateTArrayType(innerProperty)
			end
		end

		classField = ffi.cast("struct UProperty*", classField.UField.Next)
	end

	-- All the requisite data structures should have been generated by now, so we can generate this one
	classText = classText .. self:GenerateDefinition()
	return classText
end

function Class:GetFieldsSize()
	return self.ClassObj.UStruct.PropertySize
end

function Class:GenerateDefinition()
	local class = self.ClassObj

	print("[SDKGen] Class " .. class:GetFullName())

	-- Start by defining the class with its name
	local classText = "struct " .. class:GetCName() .. " {\n"



	classText = classText .. "};\n\n"

	table.insert(GeneratedClasses, class)

	return classText
end

function Package:ProcessClasses()

	self:CreateFile("classes")
	self:WriteFileHeader("Class definitions")

	self:WriteCDefWrapperStart()

	-- Foreach object, check if it's a class, then check if it's in the package.
	-- If it is, then process the class
	for i=0,(engine.Objects.Count-1) do

		local obj = engine.Objects:Get(i)
		if IsNull(obj) then goto continue end

		local package_object = obj:GetPackageObject()
		if IsNull(package_object) then goto continue end
		if package_object ~= self.PackageObj then goto continue end

		if not obj:IsA(engine.Classes.UClass) then goto continue end

		self.File:write(Class.new(obj):GeneratePrereqs(self.PackageObj)) -- Generate the requisite things then generate this one

		::continue::
	end

	self:WriteCDefWrapperEnd()
	self:CloseFile()
end
